tetraploids=c('snutan', 'hconto', 'ccitra', 'achine', 'sscopa', 'etrips',  'vcuspi')
hexaploids=c('udigit', 'agerar', 'hcompr', 'blagur')
countRearrangements <- function(filepath, color_palette=muted_colors, minBlock=20) {
# Load data
data <- read.table(filepath, header = TRUE)
data <- data[data$gene != 'interanchor', ]
# Reduce to blocks and calculate stats
data <- data %>%
group_by(blockIndex) %>%
mutate(blockLength = n()) %>%
group_by(queryChr) %>%
mutate(freqStrand = names(which.max(table(strand))),
maxChr = max(queryStart),
freqRef = names(which.max(table(refChr))))
# Filter data based on block length
data <- data[data$blockLength > minBlock, ]
data$refChr <- factor(data$refChr, levels = c(paste0('Chr0', 1:9), 'Chr10'))
temp=data %>% filter(blockLength>minBlock) %>% group_by(queryChr)%>% summarize(n=length(unique(refChr)))
sum(temp$n>1)
}
for(i in diploids){
print(countRearrangements(Sys.glob(paste0('../syntenic_anchors/anchors/', i, '-Pv-*'))))
}
for(i in tetraploids){
print(countRearrangements(Sys.glob(paste0('../syntenic_anchors/anchors//', i, '-Pv-*'))))
}
for(i in hexaploids){
print(countRearrangements(Sys.glob(paste0('../syntenic_anchors/anchors/', i, '-Pv-*')), minBlock=50))
}
for(i in c('zmB735')){
print(countRearrangements(Sys.glob(paste0('../syntenic_anchors/anchors/', i, '-Pv-*')), minBlock=50))
}
lowQualAssemblies=c('telega', 'atenui', 'rrottb')
asize$transloc=sapply(asize$V2, function(x) countRearrangements(Sys.glob(paste0('../syntenic_anchors/anchors/', x, '-Pv-*')), minBlock=30))
asize$transloc=ifelse(asize$haploid, asize$transloc, asize$transloc/2) ## if haploid, this is true number, if allelic, don't count each allele
asize %>% group_by(ploidy) %>% summarize(translocMean=mean(transloc, na.rm=T), scaledTranslocMean=mean(scaledTransloc, na.rm=T))
## numbers for paper
asize %>% filter(!V2 %in% lowQualAssemblies) %>% group_by(ploidy) %>% summarize(meanrearr=mean(transloc, na.rm=T), meanscaled=mean(scaledTransloc, na.rm=T))
ggplot(asize[!asize$V2%in%lowQualAssemblies,], aes(x=ploidy, y=scaledTransloc, group=ploidy, color=ploidy)) + geom_boxplot(outlier.shape=NA) +geom_point(position = position_jitter(seed = 1),  size=2, aes(shape=haploid))+ geom_text(aes(label=V2), position = position_jitter(seed = 1)) + scale_color_manual(values=ploidycolors) + theme(legend.position='none')+ ggpubr::stat_compare_means(aes(group=ploidy, x=ploidy), label = 'p.signif', show.legend = F,ref.group = "Diploid", label.y=6) + ylab('Translocations per haploid equivalent') + xlab('Ploidy')
ggplot(asize, aes(x=ploidy, y=scaledTransloc, group=ploidy, color=ploidy)) + geom_boxplot(outlier.shape=NA) +geom_point(position = position_jitter(seed = 1),  size=2, aes(shape=haploid))+ geom_text(aes(label=V2), position = position_jitter(seed = 1)) + scale_color_manual(values=ploidycolors) + theme(legend.position='none')+ ggpubr::stat_compare_means(aes(group=ploidy, x=ploidy), label = 'p.signif', show.legend = F,ref.group = "Diploid", label.y=6) + ylab('Translocations per haploid equivalent') + xlab('Ploidy')
## no clear relatioonship with parental age?? fair if it's all cytotype age...
ggplot(asize[!asize$V2%in%lowQualAssemblies,], aes(x=mya, y=scaledTransloc, color=ploidy)) + geom_point() + scale_color_manual(values=ploidycolors)
## translocations are related to chromosome count, reassuringly!!!
chrCount=read.table('../general_summaries/panand_chr_counts.txt', header=T)
asize$chrCount=chrCount$haploidchr[match(asize$V2, chrCount$sixlettercode)]
ggplot(asize[!asize$V2%in%lowQualAssemblies,], aes(x=chrCount, y=scaledTransloc, color=ploidy)) + geom_jitter() + scale_color_manual(values=ploidycolors) + xlab('Haploid Chromosome Number') + ylab('Translocations per haploid equivalent')
ggplot(asize, aes(x=chrCount, y=scaledTransloc, color=ploidy)) + geom_jitter() + scale_color_manual(values=ploidycolors)+ xlab('Haploid Chromosome Number') + ylab('Translocations per haploid equivalent')
ggplot(asize, aes(x=chrCount, y=scaledTransloc, color=ploidy)) + geom_jitter() + geom_text(aes(label=V2)) + scale_color_manual(values=ploidycolors)+ xlab('Haploid Chromosome Number') + ylab('Translocations per haploid equivalent')
ggplot(asize, aes(x=chrCount, y=scaledTransloc, color=ploidy)) + geom_vline(xintercept=c(9,11:19,21:29), color='gray90', lty='dotted', alpha=0.3) + geom_vline(xintercept=c(10,20,30), color='gray80', lty='dashed', alpha=0.3)+ geom_jitter(size=4, width = 0.1, alpha=1) + scale_color_manual(values=ploidycolors)+ xlab('Haploid Chromosome Number') + ylab('Rearrangements per Diploid Equivalent')
summary(lm(data=asize, scaledTransloc~chrCount))
## with regression line
fig_chrrearr=ggplot(asize, aes(x=chrCount, y=scaledTransloc, color=ploidy)) + geom_vline(xintercept=c(9,11:19,21:29), color='gray90', lty='dotted', alpha=0.3) + geom_vline(xintercept=c(10,20,30), color='gray80', lty='dashed', alpha=0.3)+ geom_point(size=4, position=position_jitter(seed=9,width = 0.1), alpha=0.8, pch=1, stroke=3) + scale_color_manual(values=ploidycolors)+ xlab('Haploid Chromosome Number') + ylab('Rearrangements per\nDiploid Equivalent') + stat_smooth(method='lm', aes(group=NA), se=F, color='gray80')
fig_chrrearr
## add text label for toby
ggplot(asize, aes(x=chrCount, y=scaledTransloc, color=ploidy)) + geom_vline(xintercept=c(9,11:19,21:29), color='gray90', lty='dotted', alpha=0.3) + geom_vline(xintercept=c(10,20,30), color='gray80', lty='dashed', alpha=0.3)+ geom_point(size=4, position=position_jitter(seed=9,width = 0.1), alpha=0.8, pch=1, stroke=3) + scale_color_manual(values=ploidycolors)+ xlab('Haploid Chromosome Number') + ylab('Rearrangements per Diploid Equivalent') + stat_smooth(method='lm', aes(group=NA), se=F, color='gray80') + geom_text_repel(aes(label=V2))
## not scaled to diploid
ggplot(asize, aes(x=chrCount, y=transloc, color=ploidy)) + geom_vline(xintercept=c(9,11:19,21:29), color='gray90', lty='dotted', alpha=0.3) + geom_vline(xintercept=c(10,20,30), color='gray80', lty='dashed', alpha=0.3)+ geom_jitter(size=4, width = 0.1, alpha=1) + scale_color_manual(values=ploidycolors)+ xlab('Haploid Chromosome Number') + ylab('Rearrangements per Diploid Equivalent')
### are rearrangements happening at the same position relative to paspalum?
countRearrangementsPasp <- function(filepath, query='queryName', color_palette=muted_colors, minBlock=20) {
# Load data
data <- read.table(filepath, header = TRUE)
data <- data[data$gene != 'interanchor', ]
# Reduce to blocks and calculate stats
data <- data %>%
group_by(blockIndex) %>%
mutate(blockLength = n(), blockEnd=max(referenceEnd)) %>%
group_by(queryChr) %>%
mutate(freqStrand = names(which.max(table(strand))),
maxChr = max(queryStart),
freqRef = names(which.max(table(refChr))))
# Filter data based on block length
data <- data[data$blockLength > minBlock, ]
data$refChr <- factor(data$refChr, levels = c(paste0('Chr0', 1:9), 'Chr10'))
temp=data %>% filter(blockLength>minBlock) %>% group_by(refChr, queryChr, blockIndex, blockLength, blockEndWindow=round(blockEnd,-6)) %>% dplyr::summarize(ick=n())
temp$query=query
return(temp[,c('refChr', 'blockLength', 'blockEndWindow', 'query')])
}
for(i in c('zmB735')){
print(countRearrangementsPasp(Sys.glob(paste0('../syntenic_anchors/anchors/', i, '-Pv-*')), minBlock=50, query=i))
}
## i think this is interesting but not helpful, since these aren't just the regions that
paspBreaks=do.call(rbind, lapply(asize$V2, function(x) countRearrangementsPasp(Sys.glob(paste0('../syntenic_anchors/anchors/', x, '-Pv-*')), minBlock=30, query=x)))
paspBreaks$ploidy=asize$ploidy[match(paspBreaks$query, asize$V2)]
ggplot(paspBreaks, aes(x=blockEndWindow, group=ploidy, fill=ploidy, color=ploidy)) + geom_histogram(binwidth=1e6) + facet_wrap(~refChr, nrow=1) + scale_color_manual(values=ploidycolors) + scale_fill_manual(values=ploidycolors)
## toby's suggestion - count proportion of assembly covered by syntenic blocks
syntenicCoverage <- function(filepath, color_palette=muted_colors, minBlock=20) {
# Load data
data <- read.table(filepath, header = TRUE)
data <- data[data$gene != 'interanchor', ]
# Reduce to blocks and calculate stats
data <- data %>%
group_by(blockIndex) %>%
dplyr::summarize(blockLength =max(queryEnd)-min(queryStart), nAnchors=n())
# Filter data based on block length
data <- data[data$nAnchors > minBlock, ]
#  data$refChr <- factor(data$refChr, levels = c(paste0('Chr0', 1:9), 'Chr10'))
return(sum(data$blockLength))
}
refCoverage <- function(filepath, color_palette=muted_colors, minBlock=20) {
# Load data
data <- read.table(filepath, header = TRUE)
data <- data[data$gene != 'interanchor', ]
# Reduce to blocks and calculate stats
data <- data %>%
group_by(blockIndex, refChr) %>%
dplyr::summarize(referenceEnd=max(referenceEnd), referenceStart=min(referenceStart), nAnchors=n())
# Filter data based on block length
data <- data[data$nAnchors > minBlock, ]
#  data$refChr <- factor(data$refChr, levels = c(paste0('Chr0', 1:9), 'Chr10'))
#  data=data[data$refChr%in%c(paste0('Chr0', 1:9), 'Chr10'),]
gr=reduce(GRanges(seqnames=data$refChr, IRanges(start=data$referenceStart, end=data$referenceEnd)))
return(sum(width(gr)))
}
refCoverageGenes <- function(filepath, color_palette=muted_colors, minBlock=20) {
# Load data
data <- read.table(filepath, header = TRUE)
data <- data[data$gene != 'interanchor', ]
# Reduce to blocks and calculate stats
data <- data %>%
group_by(gene, refChr) %>%
dplyr::summarize(geneCount=n())
# Filter data based on block length
#  data <- data[data$nAnchors > minBlock, ]
#  data$refChr <- factor(data$refChr, levels = c(paste0('Chr0', 1:9), 'Chr10'))
#  data=data[data$refChr%in%c(paste0('Chr0', 1:9), 'Chr10'),]
return(nrow(data))
}
asize$bpCovered30=sapply(asize$V2, function(x) syntenicCoverage(Sys.glob(paste0('../syntenic_anchors/anchors/', x, '-Pv-*')), minBlock=30))
asize$bpCovered=sapply(asize$V2, function(x) syntenicCoverage(Sys.glob(paste0('../syntenic_anchors/anchors/', x, '-Pv-*')), minBlock=2))
asize$refCovered=sapply(asize$V2, function(x) refCoverage(Sys.glob(paste0('../syntenic_anchors/anchors/', x, '-Pv-*')), minBlock=2))
asize$refGenes=sapply(asize$V2, function(x) refCoverageGenes(Sys.glob(paste0('../syntenic_anchors/anchors/', x, '-Pv-*'))))
paspsize=651047655
summary(asize$refCovered/paspsize)
pa=read.table('../syntenic_anchors/anchors/pvagin-Pv-2', header=T)
pa=pa[pa$gene!='interanchor',]
paspanchors=nrow(pa)
summary(asize$refGenes/paspanchors)
for(i in diploids){
print(syntenicCoverage(Sys.glob(paste0('../syntenic_anchors/anchors/', i, '-Pv-*')), minBlock = 3))
}
#plot_grid(
plot_grid(plot_grid(av, tz,
plot_grid(tzdp + ylab('T. dactyloides KS position (Mb)'), fig_chrrearr + theme(legend.position='bottom'), labels=c('E','F'), align='v'),  labels=c('A', '',''), align='v', ncol=1, rel_heights = c(1,1,1)),
bl, ncol=2, labels=c('', 'B'), align='h')#,
fig_chrrearr
fig_chrrearr
asize$transloc=sapply(asize$V2, function(x) countRearrangements(Sys.glob(paste0('../syntenic_anchors/anchors/', x, '-Pv-*')), minBlock=30))
asize$transloc=ifelse(asize$haploid, asize$transloc, asize$transloc/2) ## if haploid, this is true number, if allelic, don't count each allele
asize %>% group_by(ploidy) %>% summarize(translocMean=mean(transloc, na.rm=T), scaledTranslocMean=mean(scaledTransloc, na.rm=T))
asize$scaledTransloc=ifelse(asize$ploidy%in%c('Paleotetraploid', 'Tetraploid'), asize$transloc/2, ifelse(asize$ploidy=='Hexaploid', asize$transloc/3, asize$transloc))
#### haploid or not scaled by triangle/circle
ggplot(asize[!asize$V2%in%lowQualAssemblies,], aes(x=ploidy, y=scaledTransloc, group=ploidy, color=ploidy)) + geom_boxplot(outlier.shape=NA) +geom_point(position = position_jitter(seed = 1),  size=2, aes(shape=haploid))+ scale_color_manual(values=ploidycolors) + theme(legend.position='none')+ ggpubr::stat_compare_means(aes(group=ploidy, x=ploidy), label = 'p.signif', show.legend = F,ref.group = "Diploid", label.y=6) + ylab('Translocations per haploid equivalent') + xlab('Ploidy')
## final set
ggplot(asize[!asize$V2%in%lowQualAssemblies,], aes(x=ploidy, y=scaledTransloc, group=ploidy, color=ploidy)) + geom_boxplot(outlier.shape=NA) +geom_point(position = position_jitter(seed = 1),  size=3)+ scale_color_manual(values=ploidycolors) + theme(legend.position='none')+ ggpubr::stat_compare_means(aes(group=ploidy, x=ploidy), label = 'p.signif', show.legend = F,ref.group = "Diploid", label.y=6) + ylab('Rearrangements per haploid equivalent') + xlab('Ploidy')
## with bad assemblies
ggplot(asize, aes(x=ploidy, y=scaledTransloc, group=ploidy, color=ploidy)) + geom_boxplot(outlier.shape=NA) +geom_point(position = position_jitter(seed = 1),  size=3)+ scale_color_manual(values=ploidycolors) + theme(legend.position='none')+ ggpubr::stat_compare_means(aes(group=ploidy, x=ploidy), label = 'p.signif', show.legend = F,ref.group = "Diploid", label.y=6) + ylab('Rearrangments per haploid equivalent') + xlab('Ploidy')
## and unscaled
## final set
ggplot(asize[!asize$V2%in%lowQualAssemblies,], aes(x=ploidy, y=transloc, group=ploidy, color=ploidy)) + geom_boxplot(outlier.shape=NA) +geom_point(position = position_jitter(seed = 1),  size=3)+ scale_color_manual(values=ploidycolors) + theme(legend.position='none')+ ggpubr::stat_compare_means(aes(group=ploidy, x=ploidy), label = 'p.signif', show.legend = F,ref.group = "Diploid", label.y=9.5) + ylab('Rearrangements') + xlab('Ploidy')
## with bad assemblies
ggplot(asize, aes(x=ploidy, y=transloc, group=ploidy, color=ploidy)) + geom_boxplot(outlier.shape=NA) +geom_point(position = position_jitter(seed = 1),  size=3)+ scale_color_manual(values=ploidycolors) + theme(legend.position='none')+ ggpubr::stat_compare_means(aes(group=ploidy, x=ploidy), label = 'p.signif', show.legend = F,ref.group = "Diploid", label.y=9.5) + ylab('Rearrangements') + xlab('Ploidy')
## numbers for paper
asize %>% filter(!V2 %in% lowQualAssemblies) %>% group_by(ploidy) %>% summarize(meanrearr=mean(transloc, na.rm=T), meanscaled=mean(scaledTransloc, na.rm=T))
ggplot(asize[!asize$V2%in%lowQualAssemblies,], aes(x=ploidy, y=scaledTransloc, group=ploidy, color=ploidy)) + geom_boxplot(outlier.shape=NA) +geom_point(position = position_jitter(seed = 1),  size=2, aes(shape=haploid))+ geom_text(aes(label=V2), position = position_jitter(seed = 1)) + scale_color_manual(values=ploidycolors) + theme(legend.position='none')+ ggpubr::stat_compare_means(aes(group=ploidy, x=ploidy), label = 'p.signif', show.legend = F,ref.group = "Diploid", label.y=6) + ylab('Translocations per haploid equivalent') + xlab('Ploidy')
ggplot(asize, aes(x=ploidy, y=scaledTransloc, group=ploidy, color=ploidy)) + geom_boxplot(outlier.shape=NA) +geom_point(position = position_jitter(seed = 1),  size=2, aes(shape=haploid))+ geom_text(aes(label=V2), position = position_jitter(seed = 1)) + scale_color_manual(values=ploidycolors) + theme(legend.position='none')+ ggpubr::stat_compare_means(aes(group=ploidy, x=ploidy), label = 'p.signif', show.legend = F,ref.group = "Diploid", label.y=6) + ylab('Translocations per haploid equivalent') + xlab('Ploidy')
## no clear relatioonship with parental age?? fair if it's all cytotype age...
ggplot(asize[!asize$V2%in%lowQualAssemblies,], aes(x=mya, y=scaledTransloc, color=ploidy)) + geom_point() + scale_color_manual(values=ploidycolors)
## translocations are related to chromosome count, reassuringly!!!
chrCount=read.table('../general_summaries/panand_chr_counts.txt', header=T)
asize$chrCount=chrCount$haploidchr[match(asize$V2, chrCount$sixlettercode)]
ggplot(asize[!asize$V2%in%lowQualAssemblies,], aes(x=chrCount, y=scaledTransloc, color=ploidy)) + geom_jitter() + scale_color_manual(values=ploidycolors) + xlab('Haploid Chromosome Number') + ylab('Translocations per haploid equivalent')
ggplot(asize, aes(x=chrCount, y=scaledTransloc, color=ploidy)) + geom_jitter() + scale_color_manual(values=ploidycolors)+ xlab('Haploid Chromosome Number') + ylab('Translocations per haploid equivalent')
ggplot(asize, aes(x=chrCount, y=scaledTransloc, color=ploidy)) + geom_jitter() + geom_text(aes(label=V2)) + scale_color_manual(values=ploidycolors)+ xlab('Haploid Chromosome Number') + ylab('Translocations per haploid equivalent')
ggplot(asize, aes(x=chrCount, y=scaledTransloc, color=ploidy)) + geom_vline(xintercept=c(9,11:19,21:29), color='gray90', lty='dotted', alpha=0.3) + geom_vline(xintercept=c(10,20,30), color='gray80', lty='dashed', alpha=0.3)+ geom_jitter(size=4, width = 0.1, alpha=1) + scale_color_manual(values=ploidycolors)+ xlab('Haploid Chromosome Number') + ylab('Rearrangements per Diploid Equivalent')
summary(lm(data=asize, scaledTransloc~chrCount))
## with regression line
fig_chrrearr=ggplot(asize, aes(x=chrCount, y=scaledTransloc, color=ploidy)) + geom_vline(xintercept=c(9,11:19,21:29), color='gray90', lty='dotted', alpha=0.3) + geom_vline(xintercept=c(10,20,30), color='gray80', lty='dashed', alpha=0.3)+ geom_point(size=4, position=position_jitter(seed=9,width = 0.1), alpha=0.8, pch=1, stroke=3) + scale_color_manual(values=ploidycolors)+ xlab('Haploid Chromosome Number') + ylab('Rearrangements per\nDiploid Equivalent') + stat_smooth(method='lm', aes(group=NA), se=F, color='gray80')
fig_chrrearr
## add text label for toby
ggplot(asize, aes(x=chrCount, y=scaledTransloc, color=ploidy)) + geom_vline(xintercept=c(9,11:19,21:29), color='gray90', lty='dotted', alpha=0.3) + geom_vline(xintercept=c(10,20,30), color='gray80', lty='dashed', alpha=0.3)+ geom_point(size=4, position=position_jitter(seed=9,width = 0.1), alpha=0.8, pch=1, stroke=3) + scale_color_manual(values=ploidycolors)+ xlab('Haploid Chromosome Number') + ylab('Rearrangements per Diploid Equivalent') + stat_smooth(method='lm', aes(group=NA), se=F, color='gray80') + geom_text_repel(aes(label=V2))
## not scaled to diploid
ggplot(asize, aes(x=chrCount, y=transloc, color=ploidy)) + geom_vline(xintercept=c(9,11:19,21:29), color='gray90', lty='dotted', alpha=0.3) + geom_vline(xintercept=c(10,20,30), color='gray80', lty='dashed', alpha=0.3)+ geom_jitter(size=4, width = 0.1, alpha=1) + scale_color_manual(values=ploidycolors)+ xlab('Haploid Chromosome Number') + ylab('Rearrangements per Diploid Equivalent')
### are rearrangements happening at the same position relative to paspalum?
countRearrangementsPasp <- function(filepath, query='queryName', color_palette=muted_colors, minBlock=20) {
# Load data
data <- read.table(filepath, header = TRUE)
data <- data[data$gene != 'interanchor', ]
# Reduce to blocks and calculate stats
data <- data %>%
group_by(blockIndex) %>%
mutate(blockLength = n(), blockEnd=max(referenceEnd)) %>%
group_by(queryChr) %>%
mutate(freqStrand = names(which.max(table(strand))),
maxChr = max(queryStart),
freqRef = names(which.max(table(refChr))))
# Filter data based on block length
data <- data[data$blockLength > minBlock, ]
data$refChr <- factor(data$refChr, levels = c(paste0('Chr0', 1:9), 'Chr10'))
temp=data %>% filter(blockLength>minBlock) %>% group_by(refChr, queryChr, blockIndex, blockLength, blockEndWindow=round(blockEnd,-6)) %>% dplyr::summarize(ick=n())
temp$query=query
return(temp[,c('refChr', 'blockLength', 'blockEndWindow', 'query')])
}
for(i in c('zmB735')){
print(countRearrangementsPasp(Sys.glob(paste0('../syntenic_anchors/anchors/', i, '-Pv-*')), minBlock=50, query=i))
}
## i think this is interesting but not helpful, since these aren't just the regions that
paspBreaks=do.call(rbind, lapply(asize$V2, function(x) countRearrangementsPasp(Sys.glob(paste0('../syntenic_anchors/anchors/', x, '-Pv-*')), minBlock=30, query=x)))
paspBreaks$ploidy=asize$ploidy[match(paspBreaks$query, asize$V2)]
ggplot(paspBreaks, aes(x=blockEndWindow, group=ploidy, fill=ploidy, color=ploidy)) + geom_histogram(binwidth=1e6) + facet_wrap(~refChr, nrow=1) + scale_color_manual(values=ploidycolors) + scale_fill_manual(values=ploidycolors)
#plot_grid(
plot_grid(plot_grid(av, tz,
plot_grid(tzdp + ylab('T. dactyloides KS position (Mb)'), fig_chrrearr + theme(legend.position='bottom'), labels=c('E','F'), align='v'),  labels=c('A', '',''), align='v', ncol=1, rel_heights = c(1,1,1)),
bl, ncol=2, labels=c('', 'B'), align='h')#,
tzdp=process_anchors_to_dotplot_ZeaTrip('anchors/tdacs1-zB73v5-2', paspalum_tripsacum = 'anchors/tdacs1-Pv-2', paspalum_maize = 'anchors/zmB735-Pv-4', color_palette=muted_colors, minBlock=10, refChrs = paste0('chr',1:10), queryChrs=paste0('chr',1:18), ylabelspecies='T. dactyloides KS ')
tzdp+ ylab('T. dactyloides KS position (Mb)')
process_anchors_to_dotplot_ZeaTrip <- function(filepath,
paspalum_tripsacum,
paspalum_maize,
color_palette=muted_colors, minBlock=10, title='', refChrs=c(paste0('Chr0', 1:9), 'Chr10'), queryChrs='',
queryChrtoFlip='', ylabelspecies='', pathtokaryotype='', pathtoalluvial='', ploidy='Paleotetraploid', origChrOrientation=F) {
# Load data
data <- read.table(filepath, header = TRUE)
data <- data[data$gene != 'interanchor', ]
pasptrip=read.table(paspalum_tripsacum, header=T)
pasptrip=pasptrip[pasptrip$gene!='interanchor',]
paspzea=read.table(paspalum_maize, header=T)
paspzea=paspzea[paspzea$gene!='interanchor',]
dataGRtrip=GRanges(seqnames=data$queryChr, IRanges(start=data$queryStart, end=data$queryEnd))
dataGRzea=GRanges(seqnames=data$refChr, IRanges(start=data$referenceStart, end=data$referenceEnd))
pasptripGR=GRanges(seqnames=pasptrip$queryChr, IRanges(start=pasptrip$queryStart, end=pasptrip$queryEnd))
pasptripGR$paspChr=pasptrip$refChr
paspzeaGR=GRanges(seqnames=paspzea$queryChr, IRanges(start=paspzea$queryStart, end=paspzea$queryEnd))
paspzeaGR$paspChr=paspzea$refChr
overlaps <- findOverlaps(dataGRtrip, pasptripGR)
# Step 2: Create a vector for paspChr with NA values as default
paspChr <- rep(NA, length(dataGRtrip))
# Step 3: Assign paspChr values based on the overlaps
paspChr[queryHits(overlaps)] <- pasptripGR$paspChr[subjectHits(overlaps)]
# Step 4: Add the paspChr column to dataGRtrip
dataGRtrip$paspChr <- paspChr
data$tripPaspChr=paspChr
##zea
overlaps <- findOverlaps(dataGRzea, paspzeaGR)
# Step 2: Create a vector for paspChr with NA values as default
paspChr <- rep(NA, length(dataGRzea))
# Step 3: Assign paspChr values based on the overlaps
paspChr[queryHits(overlaps)] <- paspzeaGR$paspChr[subjectHits(overlaps)]
# Step 4: Add the paspChr column to dataGRtrip
dataGRzea$paspChr <- paspChr
data$zeaPaspChr=paspChr
data=data %>% group_by(blockIndex) %>%  mutate(commonTripPasp = as.character(names(which.max(table(tripPaspChr, useNA="always")))[1]),
commonZeaPasp = as.character(names(which.max(table(zeaPaspChr, useNA="always")))[1]))
data=data %>%
mutate(commonPaspChr = case_when(
is.na(commonTripPasp) ~ commonZeaPasp,             # If col1 is NA, use col2
is.na(commonZeaPasp) ~ commonTripPasp,             # If col2 is NA, use col1
commonTripPasp == commonZeaPasp ~ commonTripPasp,            # If both are the same, use that value
commonTripPasp != commonZeaPasp  ~ NA_character_                  # If they are different, use NA
))
## get queryChrs if they aren't supplied
if(queryChrs[1]==''){
queryChrs=unique(data$queryChr)
}
# Reduce to blocks and calculate stats
data <- data %>%
group_by(blockIndex) %>%
mutate(blockLength = dplyr::n()) %>%
group_by(queryChr) %>%
mutate(freqStrand = names(which.max(table(strand))),
maxChr = max(queryStart),
freqRef = names(which.max(table(refChr))))
# Filter data based on block length
data <- data[data$blockLength > minBlock, ]
data$refChr <- factor(data$refChr, levels = paste0('chr', 1:10))
# Reverse strand calculations
data <- data %>%
arrange(freqRef, referenceStart, queryStart)
data$queryChr <- factor(data$queryChr, levels = rev(data$queryChr[!duplicated(data$queryChr)]))
data$revQueryStart <- data$queryStart
data$revQueryStart[data$freqStrand == '-'] <- abs(data$queryStart - data$maxChr)[data$freqStrand == '-']
## flip querychr that look funny
if(queryChrtoFlip!=''){
data$revQueryStart[data$queryChr%in%queryChrtoFlip]=abs(data$queryStart - data$maxChr)[data$queryChr%in%queryChrtoFlip]
}
##### NEVERMIND! The repeats i care about aren't in b73, since the chromosome collisions occurred sooo sooo long ago
#   ## get repeats to plot knobs and centromeres
#   teb73=import.gff('~/Downloads/Zm-B73-REFERENCE-NAM-5.0.TE.gff3.gz')
#   teb73=teb73[teb73$Classification%in% c('Cent/CentC', 'knob/knob180', 'knob/TR-1', 'rDNA/spacer'),]
#   teb73_split <- split(teb73, teb73$Classification)
#   merged_teb73 <- GRanges()
#
#   # Loop over each split GRanges object, reduce and concatenate manually
#   for(i in 1:4){
#     reduced_gr <- GenomicRanges::reduce(teb73_split[[i]], min.gapwidth = 10000, ignore.strand=T)
#     reduced_gr$Classification=teb73_split[[i]]$Classification[1]
#     merged_teb73 <- c(merged_teb73, reduced_gr)
#   }
#
# merged_teb73$refChr=seqnames(merged_teb73)
# merged_teb73$referenceStart=start(merged_teb73)
# merged_teb73$referenceEnd=end(merged_teb73)
# merged_teb73=merged_teb73[seqnames(merged_teb73)%in%paste0('chr',1:10),]
#
# Create the plot
if(origChrOrientation){
p=ggplot(data[ data$refChr%in%refChrs & data$queryChr%in%queryChrs,],# & data$pasptrip==data$paspzea & !is.na(data$pasptrip), ],
aes(x = referenceStart / 1e6, y = queryStart / 1e6, color=commonPaspChr))
}else{
p= ggplot(data[ data$refChr%in%refChrs & data$queryChr%in%queryChrs,],# & data$pasptrip==data$paspzea & !is.na(data$pasptrip), ],
aes(x = referenceStart / 1e6, y = revQueryStart / 1e6, color=commonPaspChr))
}
p= p+
geom_point(size=0.5) +
facet_grid(queryChr ~ refChr, scales = 'free', space='free') +
scale_color_manual(values = color_palette) +
theme(legend.position = 'none') +
theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1)) +
geom_hline(aes(yintercept=maxChr/1e6), lty='dashed', color='gray') +
geom_vline(xintercept=0, color='gray95')+
#    geom_rect(data=data.frame(merged_teb73), aes(xmin = start/1e6, xmax = end/1e6, y=-Inf, ymin = -Inf, ymax = Inf, fill = Classification), alpha = 0.9, color=NA)+
#   scale_fill_manual(values=c("Cent/CentC" = "#ff5733", "knob/knob180" = "#33ff57", "knob/TR-1" = "#3357ff", "rDNA/spacer" = "#ff33a8")) +
#   ggtitle(paste0(ylabelspecies,', ', ploidy)) +
xlab('Z. m. ssp. mays B73 position (Mb)') +
ylab(paste0(ylabelspecies, ' position (Mb)')) +
ylab('Position (Mb)') +
theme(strip.text.y = element_text(angle = 0, hjust = 0),
strip.placement.y = "outside" ,
strip.text = element_text(size = 8, color = "darkblue", face = "bold"),
strip.background = element_rect(fill = "lightblue", color = "darkblue", linewidth = 1),
strip.text.y = element_text(angle=0, size=ystriptextsize),
axis.text.x=element_text(size=9),
axis.text.y=element_text(size=5),
panel.spacing = unit(0.1, 'lines'),
plot.title=element_text(color=ploidycolors[ploidy], size=10))+
scale_x_continuous(breaks = scales::breaks_pretty(n = 2), expand=c(0,0)) +  # Automatically choose 3 breaks for x-axis
scale_y_continuous(breaks = scales::breaks_pretty(n = 2), expand=c(0,0))    # Automatically choose 3 breaks for y-axis
#  p + annotation_custom(img, xmin = -Inf, xmax = Inf, ymin = -Inf, ymax = Inf)
p
}
tzdp=process_anchors_to_dotplot_ZeaTrip('anchors/tdacs1-zB73v5-2', paspalum_tripsacum = 'anchors/tdacs1-Pv-2', paspalum_maize = 'anchors/zmB735-Pv-4', color_palette=muted_colors, minBlock=10, refChrs = paste0('chr',1:10), queryChrs=paste0('chr',1:18), ylabelspecies='T. dactyloides KS ')
tzdp+ ylab('T. dactyloides KS position (Mb)')
process_anchors_to_dotplot_ZeaTrip <- function(filepath,
paspalum_tripsacum,
paspalum_maize,
color_palette=muted_colors, minBlock=10, title='', refChrs=c(paste0('Chr0', 1:9), 'Chr10'), queryChrs='',
queryChrtoFlip='', ylabelspecies='', pathtokaryotype='', pathtoalluvial='', ploidy='Paleotetraploid', origChrOrientation=F) {
# Load data
data <- read.table(filepath, header = TRUE)
data <- data[data$gene != 'interanchor', ]
pasptrip=read.table(paspalum_tripsacum, header=T)
pasptrip=pasptrip[pasptrip$gene!='interanchor',]
paspzea=read.table(paspalum_maize, header=T)
paspzea=paspzea[paspzea$gene!='interanchor',]
dataGRtrip=GRanges(seqnames=data$queryChr, IRanges(start=data$queryStart, end=data$queryEnd))
dataGRzea=GRanges(seqnames=data$refChr, IRanges(start=data$referenceStart, end=data$referenceEnd))
pasptripGR=GRanges(seqnames=pasptrip$queryChr, IRanges(start=pasptrip$queryStart, end=pasptrip$queryEnd))
pasptripGR$paspChr=pasptrip$refChr
paspzeaGR=GRanges(seqnames=paspzea$queryChr, IRanges(start=paspzea$queryStart, end=paspzea$queryEnd))
paspzeaGR$paspChr=paspzea$refChr
overlaps <- findOverlaps(dataGRtrip, pasptripGR)
# Step 2: Create a vector for paspChr with NA values as default
paspChr <- rep(NA, length(dataGRtrip))
# Step 3: Assign paspChr values based on the overlaps
paspChr[queryHits(overlaps)] <- pasptripGR$paspChr[subjectHits(overlaps)]
# Step 4: Add the paspChr column to dataGRtrip
dataGRtrip$paspChr <- paspChr
data$tripPaspChr=paspChr
##zea
overlaps <- findOverlaps(dataGRzea, paspzeaGR)
# Step 2: Create a vector for paspChr with NA values as default
paspChr <- rep(NA, length(dataGRzea))
# Step 3: Assign paspChr values based on the overlaps
paspChr[queryHits(overlaps)] <- paspzeaGR$paspChr[subjectHits(overlaps)]
# Step 4: Add the paspChr column to dataGRtrip
dataGRzea$paspChr <- paspChr
data$zeaPaspChr=paspChr
data=data %>% group_by(blockIndex) %>%  mutate(commonTripPasp = as.character(names(which.max(table(tripPaspChr, useNA="always")))[1]),
commonZeaPasp = as.character(names(which.max(table(zeaPaspChr, useNA="always")))[1]))
data=data %>%
mutate(commonPaspChr = case_when(
is.na(commonTripPasp) ~ commonZeaPasp,             # If col1 is NA, use col2
is.na(commonZeaPasp) ~ commonTripPasp,             # If col2 is NA, use col1
commonTripPasp == commonZeaPasp ~ commonTripPasp,            # If both are the same, use that value
commonTripPasp != commonZeaPasp  ~ NA_character_                  # If they are different, use NA
))
## get queryChrs if they aren't supplied
if(queryChrs[1]==''){
queryChrs=unique(data$queryChr)
}
# Reduce to blocks and calculate stats
data <- data %>%
group_by(blockIndex) %>%
mutate(blockLength = dplyr::n()) %>%
group_by(queryChr) %>%
mutate(freqStrand = names(which.max(table(strand))),
maxChr = max(queryStart),
freqRef = names(which.max(table(refChr))))
# Filter data based on block length
data <- data[data$blockLength > minBlock, ]
data$refChr <- factor(data$refChr, levels = paste0('chr', 1:10))
# Reverse strand calculations
data <- data %>%
arrange(freqRef, referenceStart, queryStart)
data$queryChr <- factor(data$queryChr, levels = rev(data$queryChr[!duplicated(data$queryChr)]))
data$revQueryStart <- data$queryStart
data$revQueryStart[data$freqStrand == '-'] <- abs(data$queryStart - data$maxChr)[data$freqStrand == '-']
## flip querychr that look funny
if(queryChrtoFlip!=''){
data$revQueryStart[data$queryChr%in%queryChrtoFlip]=abs(data$queryStart - data$maxChr)[data$queryChr%in%queryChrtoFlip]
}
##### NEVERMIND! The repeats i care about aren't in b73, since the chromosome collisions occurred sooo sooo long ago
#   ## get repeats to plot knobs and centromeres
#   teb73=import.gff('~/Downloads/Zm-B73-REFERENCE-NAM-5.0.TE.gff3.gz')
#   teb73=teb73[teb73$Classification%in% c('Cent/CentC', 'knob/knob180', 'knob/TR-1', 'rDNA/spacer'),]
#   teb73_split <- split(teb73, teb73$Classification)
#   merged_teb73 <- GRanges()
#
#   # Loop over each split GRanges object, reduce and concatenate manually
#   for(i in 1:4){
#     reduced_gr <- GenomicRanges::reduce(teb73_split[[i]], min.gapwidth = 10000, ignore.strand=T)
#     reduced_gr$Classification=teb73_split[[i]]$Classification[1]
#     merged_teb73 <- c(merged_teb73, reduced_gr)
#   }
#
# merged_teb73$refChr=seqnames(merged_teb73)
# merged_teb73$referenceStart=start(merged_teb73)
# merged_teb73$referenceEnd=end(merged_teb73)
# merged_teb73=merged_teb73[seqnames(merged_teb73)%in%paste0('chr',1:10),]
#
# Create the plot
if(origChrOrientation){
p=ggplot(data[ data$refChr%in%refChrs & data$queryChr%in%queryChrs,],# & data$pasptrip==data$paspzea & !is.na(data$pasptrip), ],
aes(x = referenceStart / 1e6, y = queryStart / 1e6, color=commonPaspChr))
}else{
p= ggplot(data[ data$refChr%in%refChrs & data$queryChr%in%queryChrs,],# & data$pasptrip==data$paspzea & !is.na(data$pasptrip), ],
aes(x = referenceStart / 1e6, y = revQueryStart / 1e6, color=commonPaspChr))
}
p= p+
geom_point(size=0.5) +
facet_grid(queryChr ~ refChr, scales = 'free', space='free') +
scale_color_manual(values = color_palette) +
theme(legend.position = 'none') +
theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1)) +
geom_hline(aes(yintercept=maxChr/1e6), lty='dashed', color='gray') +
geom_vline(xintercept=0, color='gray95')+
#    geom_rect(data=data.frame(merged_teb73), aes(xmin = start/1e6, xmax = end/1e6, y=-Inf, ymin = -Inf, ymax = Inf, fill = Classification), alpha = 0.9, color=NA)+
#   scale_fill_manual(values=c("Cent/CentC" = "#ff5733", "knob/knob180" = "#33ff57", "knob/TR-1" = "#3357ff", "rDNA/spacer" = "#ff33a8")) +
#   ggtitle(paste0(ylabelspecies,', ', ploidy)) +
xlab('Z. m. ssp. mays B73 position (Mb)') +
ylab(paste0(ylabelspecies, ' position (Mb)')) +
ylab('Position (Mb)') +
theme(strip.text.y = element_text(angle = 0, hjust = 0),
strip.placement.y = "outside" ,
strip.text = element_text(size = 8, color = "darkblue", face = "bold"),
strip.background = element_rect(fill = "lightblue", color = "darkblue", linewidth = 1),
axis.text.x=element_text(size=9),
axis.text.y=element_text(size=5),
panel.spacing = unit(0.1, 'lines'),
plot.title=element_text(color=ploidycolors[ploidy], size=10))+
scale_x_continuous(breaks = scales::breaks_pretty(n = 2), expand=c(0,0)) +  # Automatically choose 3 breaks for x-axis
scale_y_continuous(breaks = scales::breaks_pretty(n = 2), expand=c(0,0))    # Automatically choose 3 breaks for y-axis
#  p + annotation_custom(img, xmin = -Inf, xmax = Inf, ymin = -Inf, ymax = Inf)
p
}
tzdp=process_anchors_to_dotplot_ZeaTrip('anchors/tdacs1-zB73v5-2', paspalum_tripsacum = 'anchors/tdacs1-Pv-2', paspalum_maize = 'anchors/zmB735-Pv-4', color_palette=muted_colors, minBlock=10, refChrs = paste0('chr',1:10), queryChrs=paste0('chr',1:18), ylabelspecies='T. dactyloides KS ')
tzdp+ ylab('T. dactyloides KS position (Mb)')
td=process_anchors_to_dotplot_Tripsacinae(filepath = '../syntenic_anchors/anchors/tdacs1-Pv-2', minBlock=20, ylabelspecies = 'T. dactyloides FL')
td
zm=process_anchors_to_dotplot_Tripsacinae(filepath = '../syntenic_anchors/anchors/zmB735-Pv-4', minBlock=20, ylabelspecies='Z. mays subsp. mays B73')
zm
tz=plot_grid(td, zm, ncol=2, align='hv', labels=c('C', 'D'))
tz
#plot_grid(
plot_grid(plot_grid(av, tz,
plot_grid(tzdp + ylab('T. dactyloides KS position (Mb)'), fig_chrrearr + theme(legend.position='bottom'), labels=c('E','F'), align='v'),  labels=c('A', '',''), align='v', ncol=1, rel_heights = c(1,1,1)),
bl, ncol=2, labels=c('', 'B'), align='h')#,
plot_grid(plot_grid(av, td , ncol=1, align='hv', rel_heights = c(1,2)), bl, ncol=2, align='h')
av
## dynamically determine plot dimenstions
facet_sums <- av %>%
group_by(PANEL) %>%  # PANEL corresponds to facets
summarise(total_y = sum(y), total_x=sum(x))
# Total y sum across all facets
total_y_sum <- sum(facet_sums$total_y)
total_x_sum=sum(facet_sums$total_x)
# Set dynamic height based on total sum
plot_height <- total_y_sum / 100  # Adjust scale as needed
# Extract the plotted data
plot_data <- ggplot_build(av)$data[[1]]  # Access the data used in the plot
# Extract facet information
facet_mapping <- ggplot_build(p)$layout$layout %>%
select(PANEL, facet) %>%
mutate(facet = factor(facet, levels = levels(df$facet)))
# Add facet labels to plot data
plot_data <- plot_data %>%
left_join(facet_mapping, by = c("PANEL"))
facet_sums <- plot_data %>%
group_by(facet) %>%  # PANEL corresponds to facets
summarise(total_y = sum(y), total_x=sum(x))
# Extract facet information
facet_mapping <- ggplot_build(av)$layout$layout %>%
select(PANEL, facet) %>%
mutate(facet = factor(facet, levels = levels(df$facet)))
bl
#plot_grid(
plot_grid(plot_grid(av, tz,
plot_grid(tzdp + ylab('T. dactyloides KS position (Mb)'), fig_chrrearr + theme(legend.position='bottom'), labels=c('E','F'), align='v'),  labels=c('A', '',''), align='v', ncol=1, rel_heights = c(1,1,1)),
bl, ncol=2, labels=c('', 'B'), align='h')#,
plot_grid(plot_grid(av, fig_chrrearr + theme(legend.position='bottom') , ncol=1, align='hv', labels=c('A', 'C')), bl, ncol=2, align='h')
plot_grid(plot_grid(av, fig_chrrearr + theme(legend.position='bottom') , ncol=1, align='v', labels=c('A', 'C')), bl, ncol=2, align='h')
plot_grid(plot_grid(av, fig_chrrearr + theme(legend.position='bottom') , ncol=1, align='h', labels=c('A', 'C')), bl, ncol=2, align='h')
plot_grid(plot_grid(av, fig_chrrearr + theme(legend.position='bottom') , rel_heights=c(2,1),ncol=1, align='h', labels=c('A', 'C')), bl, ncol=2, align='h')
